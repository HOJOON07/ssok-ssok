# 카피 온 라이트

## 장바구니와 제품에 대한 동작 리스트

- 장바구니

  - 제품 개수 가져오기 (읽기)
  - 제품 이름으로 제품 가져오기 (읽기)
  - 제품 추가하기 (쓰기)
  - 제품 이름으로 제품 빼기 (쓰기)
  - 제품 이름으로 제품 구매 수량 바꾸기 (쓰기)

- 제품
  - 가격 설정하기
  - 가격 가져오기
  - 이름 가져오기

### 모든 동작을 불변형으로 만든다? (p 100)

## 동작을 읽기와 쓰기로 구분하기

- 읽기는 데이터를 바꾸지 않고 정보를 꺼낸다
- 쓰기는 어떻게든 데이터를 바꾼다.

### 읽기 동작을 하면서 동시에 쓰는 동작도 가능하다.

- shift 메서드

```
var a = [1,2,3,4];
var b = a.shift();
console.log(a)
console.log(b)
```

> a는 2,3,4 b는 1

## 이걸 읽기와 쓰기로 분리할 수 있을까?

### shift를 함수로 만들기

- shift 는 단순히 배열의 첫번째 값을 리턴한다.

```
const shiftFunc = (array) => array[0]
```

```
const writeShiftFunc = (array) => {
  array.shift();
}
```

#### 카피 온 라이트

```
const drop_first = (array) => {
 array.shift();
}
```

```
const copy_drop_first = (array) =>{
  const newArray = [...array][0];
  return newArray;
}
```

### 카피-온-라이트의 동작 세 단계

- 복사본 만들기
- 복사본 변경하기
- 복사본 리턴하기

```
function add_element_last (array, elem){
  var new_array = array.slice();
  new_array.push(elem);
  return new_array;
}
```

> 읽기 이다. 데이터를 바꾸지 않았고 정보를 리턴했기 때문이다.

```
const remove_item_by_name = (cart,name) =>{
  //생략
}
```

#### remove_item_by_name 함수

이 함수는 인자로 받는 cart를 변경한다.

1. 복사하기

```
var new_cart = cart.slice();
```

2. 원래 cart -> 복사본 new_cart로 바꿔서 사용하기

   > for문에 있는 cart -> new_cart

3. 복사본 리턴하기

#### 별거 없다 복사한 거 리턴만 해주면 됨.

> return new_cart;

> 함수를 사용하고 있는 곳에서 전역변수에 할당만 해주면 됨, 상황에 맞게 고쳐주기만 하면 된다.

## 읽기와 쓰기를 분리하는 접근 방법은 분리된 함수를 따로 쓸 수 있기 때문이다.

> shift의 경우 원래는 무조건 함께 쓸 수밖에 없었지만 이제 선택해서 쓸 수 있다.

## 값을 두개 리턴하는 함수 만들어보기

### shift를 감싸서 함수로 만들기

```
const shiftFunc = (array) => {
  const newArray = [...array];
  return {
    first : newArray[0],
    array : newArray,
  }
}
```

```
const shiftFunc = (array) => {
  return {
    first: first_element(array),
    array: drop_first(array)
  }
}
```

## 불변 데이터 구조를 읽는 것은 계산이다.

- 변경 가능한 데이터를 읽는 것은 액션
- 쓰기는 데이터를 변경 가능한 구조로 만든다.
- 어떤 데이터에 쓰기가 없다면 데이터는 변경 불가능한 데이터이다.
- 불변 데이터 구조를 읽는 것은 계산이다.
- 쓰기를 읽기로 바꾸면 코드에 계산이 많아진다.
